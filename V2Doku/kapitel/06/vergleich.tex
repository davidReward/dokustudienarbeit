\section{Vergleich Ist-/Soll-Zustand}
\label{sec:VergleichIstSollZustand}
In diesem Unterkapitel wird der erreichte Ist- Zustand mit dem geforderten Soll-Zustand verglichen. Hierfür werden die gleichen Gliederungspunkte wie in der Problemstellung (siehe Kapitel \ref{sec:SollZustand}) verwendet und hinsichtlich ihrer Realisierung bewertet.
\paragraph{Arduino} Das Ziel war es mit Hilfe des Arduinos verschiedene Sensordaten auszuwerten. Dieser Punkt konnte vollständig erfüllt werden. Die Arduinos können von verschiedenen Sensoren die Messwerte bestimmen. Die Sensoren können je nach Anforderungsprofil an das Sensorknotenboard gesteckt werden. Jeder Sensorknoten hat mindestens den DHT22 oder DHT11 installiert, dieser kann die Temperatur und Luftfeuchtigkeit bestimmen. Alle verwendeten Sensoren wurden bereits in Kapitel \ref{sec:VerwendeteSensoren} vorgestellt.

Ein weiteres Ziel war die Erstellung eines Mesh-Netzes mit Hilfe eines Funkmoduls. Dies wurde mit dem Funkmodul nRF24l01 (siehe Kapitel \ref{sec:MachineZuMachineKommunikation}) realisiert. Die normalen Sensorknoten bauen gemeinsam ein Art Mesh-Netz auf, bei dem über mehrere Knoten hinweg Nachrichten geschickt werden können. Die Nachrichten werden per Broadcast an alle umliegenden Stationen weitergeleitet. Der verwendete Algorithmus wird in Kapitel \ref{sec:MeshAlgorithmus} genauer erklärt.

Als letzter Punkt bei den Arduinos war die Entwicklung eines energiesparenden Sensorknotens. Der entwickelte Sensorknoten verwendet verschiedene Techniken um möglichst wenig Strom zu verbrauchen(siehe Kapitel \ref{sec:Energiesparmodus}). Der energiesparende Sensorknoten benötigt im Sleep-Modus nur noch 182$\mu$A. Durch diesem geringen Stromverbrauch kann der Sensorknoten über Monate hinweg autark mit Batterien betrieben werden.
\paragraph{Raspberry Pi} Der Raspberry sollte als Gateway zum Internet dienen. Dieser Soll-Zustand wurde vollständig erreicht. Der Raspberry Pi empfängt mit demselben Funkmodul wie die Sensorknoten die Nachrichten der Messwerte. Nach dem Empfangen der Nachricht enkodiert der Raspberry Pi die enthaltene Nachricht und speichert sie in der Datenbank ab. Hierbei werden nur Messwerte von bekannten Sensorknoten und Nachrichten gespeichert die noch nicht in der Datenbank gespeichert wurden. Damit jede Nachricht eindeutig identifizierbar ist wir ein Hash aus der ID des Arduinos, der Nachrichten ID und dem hochgezählten Zeitstemple gebildet (siehe Kapitel \ref{sec:hashing}). 

Das Programm zum Empfang der Messwerte startet sobald der Raspberrry fertig gebootet ist (siehe Kapitel \ref{sec:scheduling}).
\paragraph{Webservice} Das Soll-Zustand dieses Unterpunktes war es die Sensordaten dauerhaft in einer Datenbank zu speichern und diese Daten mit Hilfe eines REST-Webservice wieder zur Verfügung zu stellen. Dieser Soll-Zustand wurde vollständig erfüllt. Die Implementierung wurde mit Hilfe des Microframework Flask in Python vorgenommen. Der REST-Service stellt vier Routen zur Verfügung die ein Ergebnis in der JSON Notation bereitstellen. Es lassen sich alle Stationen ausgeben, die neusten Messwerte einer Station, die Messdaten einer bestimmten Messgröße über einen bestimmten Zeitraum und die Ressource eines bestimmten Messwertes (siehe Kapitel \ref{sec:webservice}).
\paragraph{Datenrepäsentation} Als letzte Anforderung war noch die Präsentation der Daten, hierfür sollte ein Frontend entwickelt werden. Das Frontend wurde mit Hilfe verschiedener Webtechnologien entwickelt. Es wurde eine Webseite entwickelt bei dem sich der Nutzer anmelden kann und nach der Authentifizierung eine Übersicht über alle Sensorknoten erhält. Zusätzlich kann sich der Nutzer die aktuellsten Messwerte und zu jedem Sensor ein Kurvendiagramm über ein vom Benutzter definierten Zeitraum ausgeben lassen. Darstellen (siehe Kapitel \ref{sec:Datenvisualiserung}).


